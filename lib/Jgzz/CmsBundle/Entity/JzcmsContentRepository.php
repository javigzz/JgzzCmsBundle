<?php

namespace Jgzz\CmsBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Jgzz\DoctrineI18n\Entity\Repository\TranslatableRepository as TranslatableRepository;

/**
 * JzcmsContentRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class JzcmsContentRepository extends TranslatableRepository
{
	
	protected $tabla = 'jzcmscontent';
	
	protected $tabla_i18n = 'jzcmscontenti18n';
	
	/*
	 * nombre de la clase base de contenidos. Clase que guarda 
	 * la relación de descendencia entre contenidos
	 */
	protected $base_content_entity_class = 'JgzzCmsBundle:JzcmsContent';
	
	
	public function findOneBySlugAbsoluto($slug_absoluto)
	{
		$qb = $this -> createQueryBuilderToTrans();

		$qb	-> add('where', $qb->expr()->eq('t.slug_absoluto', ':slug_absluto'))
		
		->setParameter('slug_absluto', $slug_absoluto);

		$content = $qb->getQuery() -> getSingleResult();

		$trans = $content->getTranslations();

		foreach ($trans as $translation) {
			if ($slug_absoluto == $translation->getSlugAbsoluto()){
				$content->setCurrentTranslation($translation->getLocale());
			}
		}

		return $content;
	}

	/**
	 * Encuentra una entidad por su keyword y su locale
	 */
	public function findByKeywordLocale($key, $locale){
		
		$qb = $this->createQueryBuilderLocale($locale);
		
		// obra
		$qb -> andWhere($qb->expr()->eq('c.keyword', ':key'))
		
		->setParameter('key', $key);
		
		$res = $qb -> getQuery() -> getSingleResult();
		
		//\Doctrine\Common\Util\Debug::dump($res);
		//exit;
		
		$res->setCurrentTranslation($locale);
		
		return $res;
		
	}
	
	/**
	 * Encuentra el objeto padre en el locale actual
	 */
	public function findParentLocale($child, $locale = null){
		
		$entity_class_name = $this->getClassMetadata()->name;
		
		if(!($child instanceof $entity_class_name)){
			throw new \Exception("El objeto no es instancia de $entity_class_name, sino ".get_class($child), 1);
		}
		
		if (!($parent = $child->getParent())){
			return null;
		}
		
		$parent_id = $parent->getId();
				
		$locale = isset($locale) ? $locale : $child->getLocale();

		return $this->findLocale($locale, $parent_id, get_class($parent));
		
	}
	
	/**
	 * 
	 */


	/**
	 * Objetos Content hijos con el mismo locale que el objeto actual
	 */
	public function findChildren($parent, $locale = null){
		
		$entity_class_name = $this->getClassMetadata()->name;
		
		$entity_class_name = $this->base_content_entity_class;
		
		
		
		if(!($parent instanceof $entity_class_name)){
			//throw new \Exception("El objeto no es instancia de $entity_class_name", 1);
		}
				
		$locale = isset($locale) ? $locale : $parent->getLocale();
		
		$parent_id = $parent->getId();
		
		$obj = $this->getEntityManager()
		->createQuery("SELECT c, t FROM $entity_class_name c LEFT OUTER JOIN c.jgzz_translations t WHERE t.locale = '$locale' AND c.parent = $parent_id")
		->getResult();
		
		//echo "  objetos encontrados ".count($obj)." con parent_content_id ".$parent->getId()."\n";
		
		// recorrido de objetos contenido dependientes
		foreach ($obj as $o){
			//echo "    id: ".$o->getId();
			//\Doctrine\Common\Util\Debug::dump($o);
			//\Doctrine\Common\Util\Debug::dump($o->getTranslations());
			//$tr = $o->getTranslations();
			$tr = $this->getLocaleTranslationOrFind($locale, $o);
			//\Doctrine\Common\Util\Debug::dump($tr);
			if(isset($tr)){
				$o->setCurrentTranslation($locale);
			} else {
				throw new \Exception("No hay locale $locale en ".$o->getId());
			}
			
			//\Doctrine\Common\Util\Debug::dump($o->getCurrentTranslation());
		}
		return $obj;
	}

	
	/**
	 * Actualiza el slug absoluto de la entidad $entity basándose en el slug 
	 * absoluto de su padre (si tiene), en el idioma actual de la entidad.
	 * 
	 * TODO: Si $todos_locale == true, se actualizan los slug absolutos de la entidad
	 * en todos los idiomas para los que exista traducción.
	 */
	public function actualizaSlugAbsoluto($entity, $todos_locale = false) {

		$parent = $entity -> getParent();
		
		$separador = "/";
		
		if (!isset($parent)) {

			$slug_abs = $entity -> getSlug();
			
			$entity -> setSlugAbsoluto($slug_abs);

		} else {
			
			if ($todos_locale){
				
				
				$locale_inicio = $entity->getLocale();
				
				/* 
				 * se actualizan todos los locale de la entidad: todas las traudcciones
				 * esto es necesario por ejemplo cuando ha cambiado el padre 
				 * del que depende un contenido: esta comprobación se debe realizar en 
				 * otro sitio
				 */
				$this->findAllLocales($entity);
				
				$this->findAllLocales($parent);
				
				$translations = $entity->getTranslations();
				
				// recorrido de todos los locale
				foreach ($translations as $tr){
					
					$locale = $tr->getLocale();
					
					//echo "actualizando slug absoluto de locale: ".$locale;
					// entidad en locale
					$entity->setCurrentTranslation($locale);
					
					// entidad padre en locale
					$parent->setCurrentTranslation($locale);
				
					$slug_abs_locale = $parent->getSlugAbsoluto() . $separador . $entity -> getSlug();
					
					$entity->setSlugAbsoluto($slug_abs_locale);
					
					//echo " slug abs actualizado a: ".$entity->getSlugAbsoluto();

				}
				
				// devolvemos la entidad a su locale original
				$entity->setCurrentTranslation($locale_inicio);

			} else {
				
				// se actualiza únicamente el locale actual de la entidad
				
				$locale = $entity->getLocale();

				// TODO: esta condición se ha introducido para solventar un bug indirecto provocado al interactuar
				// con otro bundle. no convence. toda entidad en este punto debería tener un 'locale'
				if(!$locale){
					return;
				}
				
				$parent_tr = $this->getTranslationForLocale($parent, $locale);
				
				if (!isset($parent_tr)){
					throw new \Exception(sprintf("El nodo de contenido al que pertence la entidad (id: %s, clase: %s) no tiene traducción 
					para el idioma que está editando (%s). Id nodo padre: %s", $entity->getId(), get_class($entity), $locale, $parent->getId()));
					
				}
				
				$slug_abs = $parent_tr->getSlugAbsoluto() . $separador . $entity -> getSlug();

				$entity -> setSlugAbsoluto($slug_abs);

			}
		}

		
	}

	/**
	 * Actualiza el slug absoluto de las entidades hijas, y de las hijas de las hijas.
	 * Función recursiva. Excepción si se detecta descendencia circular.
	 * 
	 * TODO: parámetro para ordenar la actualización de los slugs en todos los locale
	 */
	public function transmiteSlugAHijas($entity, $parent_entity_ids = array()) {

		/* 
		 * comprobamos que no se produzcan referencias circulares: 
		 * el id de object no puede estar en array parent_entity_ids
		 */
		
		$id = $entity -> getId();
		
		if (in_array($id, $parent_entity_ids)) {
			throw new \Exception("Se ha producido una referencia circular en la descendencia de entidades, id: $id", 1);
		}

		
		array_push($parent_entity_ids, $entity -> getId());


		// búsqueda del contenido padre en el mismo locale que el objeto
		$children = $this -> findChildren($entity);
		
		
		if (empty($children)) {
			//echo "no hay hijos cuenta: ".count($children);
			return 0;
		}
		
		//\Doctrine\Common\Util\Debug::dump($children);
		

		$n_afectados = count($children);

		foreach ($children as $child) {

			// actualización del slug del hijo
			$separador = "/";
			
			$child -> setSlugAbsoluto($entity -> getSlugAbsoluto() . $separador . $child -> getSlug());

			/* 
			 * actualización de slugs de los hijos del hijo.
			 * se evitan referncias circulares al pasarle array $parent_entity_ids
			 */
			$n = $this -> transmiteSlugAHijas($child, $parent_entity_ids);

			$this -> getEntityManager() -> persist($child);

			$n_afectados += $n;
		}
		
		return $n_afectados;

	}

	public function findSinParent(){
			
		$entity_class_name = $this->getClassMetadata()->name;
			
		return $this->getEntityManager()
			->createQuery("SELECT c FROM $entity_class_name c WHERE c.parent IS NULL")
			->getResult();
	}
	
	
	/**
	 * Recupera de la bd toda la relación de slugs, relacionándolos con sus
	 * claves de contenido y locale.
	 * TODO: usar doctrine o meta información del modelo.
	 */
	public function getSlugKeyArray()
	{
		$stmt = $this->getEntityManager()
                   ->getConnection()
                   ->prepare('
      SELECT
      '.$this->tabla.'.id,
      '.$this->tabla.'.keyword,
      '.$this->tabla.'.type,
      '.$this->tabla_i18n.'.slug,
      '.$this->tabla_i18n.'.slug_absoluto,
      '.$this->tabla_i18n.'.locale,
      '.$this->tabla_i18n.'.title
      FROM
      	 '.$this->tabla.' INNER JOIN '.$this->tabla_i18n.'
      	 ON '.$this->tabla_i18n.'.parent_id = '.$this->tabla.'.id');
      $stmt->execute();
      return $stmt->fetchAll(\PDO::FETCH_ASSOC);
	}
	
	/**
	 * Copia los contenidos de los campos $campos de un locale 
	 * a otro de la entidad que se pasa.
	 * 
	 * Por defecto llama a persist
	 * XXX: revisar, aparentemente se está persistiendo incluso sin llamar a persist aquí (en setter?)
	 * 
	 * ej: copia campo 'text' de la versión 'en' en campo 'text' de la versión 'de'
	 */
	public function copiaTraduccion($entity, $locale_origen, $locale_final, $campos, $persist = true){
		
		// recuperación versión original
		
		$vo = $this->getLocaleTranslationOrFind($locale_origen, $entity);
		
		if(empty($vo)){
			throw new \Exception("No se encuentra versión original $locale_origen de la entidad", 1);
		}
		
		$vf = $entity->getTranslationOrNew($locale_final, $entity);
		
		if(empty($vf)){
			throw new \Exception("No se ha podido recuperar o crear un nuevo objeto de traducción", 1);
		}
		
		foreach ($campos as $campo) {
			
			$getter = "get".ucfirst($campo);
			
			$setter = "set".ucfirst($campo);
			
			$vf->$setter($vo->$getter());
			
		}
		
		if($persist){
			$this -> getEntityManager() -> persist($vf);
		}
		
		return(array('vo'=>$vo, 'vf'=>$vf));
		
	}
	
		
	
}